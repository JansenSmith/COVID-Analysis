---
title: "COVID Analysis - Assessing Impact of Resources and Health Care on COVID-19 Mortality"
author: "Jansen Smith"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Purpose

<please fill this in>

## Data Source and Description

<please fill this in>


## Importing required libraries
The only libraries required to run the following analysis are tidyverse and lubridate, and this code block is designed to automatically install tidyverse if the user has not already done so.

```{r libraries}
# Install the tidyverse package if not already installed
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}

# Load the tidyverse package
library(tidyverse)

# Load the lubridate package for parsing dates
library(lubridate)
```

## COVID-19 data import

Begin by reading in cases and deaths data from two main csv files, over global scope.

```{r import}

# These two sources were provided by the professor.
url = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/"
filenames = c("time_series_covid19_confirmed_global.csv",  "time_series_covid19_deaths_global.csv")
urls = str_c(url, filenames)

# Read CSV files and suppress messages about column types
global_cases = read_csv(urls[1], show_col_types = FALSE)
global_deaths = read_csv(urls[2], show_col_types = FALSE)

```

## Tidy global data
<please fill this in>

```{r tidy_global_data}

# Tidying the global cases, as demonstrated by the professor.
global_cases_tidy = global_cases %>%
  rename(Province_State = "Province/State", Country_Region = "Country/Region") %>%
  select("Province_State", "Country_Region", matches("^\\d{1,2}/\\d{1,2}/\\d{2}$")) %>%
  pivot_longer(cols = -c('Province_State',
                         'Country_Region'),
               names_to = "date",
               values_to = "cases") %>%
  mutate(date = as.Date(date, format = "%m/%d/%y"))

# Tidying the global deaths, as demonstrated by the professor.
global_deaths_tidy <- global_deaths %>%
  rename(Province_State = "Province/State", Country_Region = "Country/Region") %>%
  select("Province_State", "Country_Region", matches("^\\d{1,2}/\\d{1,2}/\\d{2}$")) %>%
  pivot_longer(cols = -c('Province_State', 'Country_Region'),
               names_to = "date",
               values_to = "deaths") %>%
  mutate(date = as.Date(date, format = "%m/%d/%y"))
```

## Join datasets
Merge datasets to allow for cases and deaths to be separate variables in the same dataset.
``` {r merge_data}

# <please fill this in>
suppressMessages({ # Messages suppressed for aesthetic reasons. Code runs without error.
  global = global_cases_tidy %>%
    full_join(global_deaths_tidy) %>%
    filter(cases > 0) %>%
    unite("Combined_Key", c(Province_State, Country_Region),
          sep = ", ",
          na.rm = TRUE,
          remove = FALSE)
})
```


## Global Lifespan & Income Per Capita Import
Importing Hans Rosling's custom dataset for The Joy of Stats, maintained by his organization GapMinder since his death in 2017. This dataset <please fill this in>
``` {r import_hans_rosling}

# This csv URL is a permalink that will remain reproducible.
global_stats_url = "https://raw.githubusercontent.com/JansenSmith/COVID-Analysis/main/JoyOfStats_data.csv"
global_stats = read_csv(global_stats_url, show_col_types = FALSE)
```

## <please fill this in>
<please fill this in>

``` {r preprocessing_and_summarization}

# Calculate the latest date in the global dataset
latest_date = max(global$date)

# Find the year of the latest date
latest_year = year(latest_date)

# Filter global_cases_tidy to get the latest data
latest_data = global %>%
  filter(date == latest_date)

# Aggregate the data at the country level by summing cases and deaths
aggregated_data = latest_data %>%
  group_by(Country_Region) %>%
  summarize(cases = sum(cases), deaths = sum(deaths)) %>%
  filter(cases > 0) %>%  # Remove countries with no cases
  mutate(Country_Region = ifelse(Country_Region == "US", "United States", Country_Region))

# Filter the global_stats dataframe to isolate the relevant year
global_stats_latest_year = global_stats %>%
  filter(latest_year == as.numeric(str_extract(`Year 1`, "\\d{4}"))) %>%
  rename(Life_Expectancy = "Life Expectancy")

```

## Deaths per Case Calculation and Global Average
To gain insights into the impact of COVID-19, we are computing the deaths per case ratio for each country by dividing the total deaths by the corresponding total cases. Furthermore, we are establishing the global average deaths per case by aggregating the deaths and cases across all countries and then calculating the ratio. This metric serves as a baseline for normalization.

``` {r deaths_per_case}
# Calculate deaths per case ratio for each country based on the latest data
global_ratio = aggregated_data %>%
  mutate(deaths_per_case = deaths / cases) %>%
  filter(!is.na(deaths_per_case))  # Remove NA values

# Calculate global average deaths per case ratio
global_avg_ratio = global_ratio %>%
  summarise(global_avg_deaths_per_case = sum(deaths) / sum(cases))

```

## Normalization Strategy
Given the inherent challenges posed by extremely small values resulting from deaths per case calculations, we are implementing a normalization technique. By dividing each country's deaths per case ratio by the global average, we are creating a normalized deaths per case metric. This adjustment ensures that the analysis remains robust and interpretable across the entire dataset.
``` {r normalization}

# Calculate normalized deaths per case metric
global_ratio_normalized = global_ratio %>%
  mutate(normalized_deaths_per_case = deaths_per_case / global_avg_ratio$global_avg_deaths_per_case)

```
## <please fill this in>
<please fill this in, mentioning that removed countries will be mentioned in bias section>
``` {r stich_it_all_together}
# Merge global_ratio_normalized with global_stats, filtering appropriately
combined_data = global_ratio_normalized %>%
  left_join(global_stats_latest_year, by = c("Country_Region" = "country (income_per_person_gdpperc.csv)")) %>%
  filter(!is.na(Income) & !is.na(normalized_deaths_per_case) & !is.na(Life_Expectancy) & !is.na(Population) & !is.na(Region)) %>%
  select(Country_Region, normalized_deaths_per_case, Income, Life_Expectancy, Population, Region) %>%
  filter(Country_Region != "Yemen") # Explicitly removed due to outlier status
```

## Predictive Model Construction & Training
In this phase, our focus turns to constructing predictive models to unravel the potential connections between Income and Life Expectancy with normalized deaths per case. Two distinct predictive models are developed: one utilizing Income as a predictor (mod_Income), and the other employing Life Expectancy (mod_Life_Expectancy). These models aim to capture patterns that could shed light on the relationship between socio-economic indicators and the severity of COVID-19 outcomes.

We initiate the process by building linear regression models using the lm() function. The models are trained on the combined_data dataset, establishing relationships between these two stand-ins for wealth and health care vs COVID mortality.

``` {r }
# Create two predictive models, using both Income and Life Expectancy to predict normalized_deaths_per_case
mod_Income = lm(normalized_deaths_per_case ~ Income, data = combined_data)
mod_Life_Expectancy = lm(normalized_deaths_per_case ~ Life_Expectancy, data = combined_data)
```

## Predictive Model Assessment

In this section, we evaluate the performance and significance of the predictive models constructed earlier. By examining the model summaries, we can gauge the strength of the relationships and assess the statistical significance of the predictors.

To interpret the models' effectiveness, we employ the summary() function on both mod_Income and mod_Life_Expectancy. This provides us with valuable information about the coefficients, p-values, and R-squared values, helping us understand the predictive power and significance of each model.

<i need to insert info here based on the actual summaries>


``` {r model_assessment}
# <please fill this in>
summary(mod_Income)
summary(mod_Life_Expectancy)
```

## Dataset Augmentation Based On Predictive Models

To deepen our analysis, we enhance the combined_data dataset by incorporating the predictive model outcomes. This augmentation involves the creation of new variables, Income_pred and Life_Expectancy_pred, which capture the predicted values from the respective models. <please mention that these predictions will be found in red in the final plots>

``` {r dataset_augmentation}

# <please fill this in>
combined_data_predictive = combined_data %>%
  mutate(Income_pred = predict(mod_Income),
         Life_Expectancy_pred = predict(mod_Life_Expectancy)) %>%
  select(1:Income, Income_pred, Life_Expectancy, Life_Expectancy_pred, everything())
```

## Graphical Representation and Visualization

We are proceeding to visualize the relationships between income and normalized deaths per case, as well as life expectancy and normalized deaths per case. Each country's marker size in the plots is being scaled proportionally to its population, effectively conveying the relative impact of COVID-19. To enhance interpretability, countries are being color-coded based on their respective regions, aiding in the identification of trends and patterns. <please mention that the predictive whatevers are dashed red lines but use more words>

``` {r visualization}

# Create a scatter plot for income vs. normalized deaths per case
income_vs_normalized_deaths = ggplot(combined_data_predictive, aes(x = Income, y = normalized_deaths_per_case)) +
  geom_point(aes(size = Population, color = Region)) +
  geom_line(aes(x = Income, y = Income_pred), linetype = "dashed", color = "red", size = 1) +  # Add  red dashed line visualizing the predictive model
  scale_size_continuous(range = c(3, 20)) +
  labs(title = "Income vs. Normalized Deaths per Case",
       x = "Income Per Capita",
       y = "Normalized Deaths per Case") +
  theme_minimal()

# Create a scatter plot for life expectancy vs. normalized deaths per case
life_expectancy_vs_normalized_deaths = ggplot(combined_data_predictive, aes(x = Life_Expectancy, y = normalized_deaths_per_case)) +
  geom_point(aes(size = Population, color = Region)) +
  geom_line(aes(x = Life_Expectancy, y = Life_Expectancy_pred), linetype = "dashed", color = "red", size = 1) +  # Add  red dashed line visualizing the predictive model
  scale_size_continuous(range = c(3, 20)) +
  labs(title = "Life Expectancy vs. Normalized Deaths per Case",
       x = "Average Life Expectancy",
       y = "Normalized Deaths per Case") +
  theme_minimal()

# Print the plots
print(income_vs_normalized_deaths)
print(life_expectancy_vs_normalized_deaths)

```

## <please fill this in>
Together, we have explored a detailed methodology for constructing a comprehensive dataset encompassing various COVID-19 and socio-economic indicators. By analyzing the deaths per case ratio, establishing a global average, and implementing a normalization strategy, we are ensuring the robustness of our findings. The subsequent graphical representations of income and life expectancy against normalized deaths per case provide visual insights into the complex interplay between health outcomes and socio-economic factors, further enriched by marker sizes and colors denoting population and region variations.


## Bias Assessment
<please fill this in>